# E2P2: Plan Maestro de Refactorización (Los 5 Deal Breakers)

Este documento detalla la estrategia para eliminar los 5 problemas críticos detectados en la auditoría, aplicando la filosofía de **"Baby Steps"** (cambios pequeños y seguros) para no romper la aplicación en producción.

## 1. Datos "Duros" -> Base de Datos (Firestore)
**Problema:** ~100 usuarios hardcodeados en `realUsersData.ts`. Inflexible y difícil de mantener.
**Estrategia:**
1.  **Limpieza:** Corregir el script de migración (hubo errores de importación y sintaxis).
2.  **Migración (Script):** Ejecutar script corregido para copiar datos a colección `users` en Firestore.
3.  **Dual Read (Feature Flag):** Modificar la App para que intente leer de Firestore primero.
    *   *Si falla/está vacío:* Lee de `realUsersData.ts` (Fallback).
    *   *Flag:* `ENABLE_FIRESTORE_USERS = true`.
4.  **Validación:** Verificar manualmente que los datos cargan bien en la UI.
5.  **Limpieza Final:** Eliminar `realUsersData.ts` solo cuando estemos 100% seguros.

## 2. App Monolítica (`App.tsx` gigante)
**Problema:** `App.tsx` tiene ~9000 líneas. Mantenimiento de pesadilla.

### Arquitectura de Referencia (Cómo dividiremos el Monolito)
Para no inventar la rueda, usaremos una estructura estándar en React que separa la **Vista** (lo que se ve) de la **Lógica** (lo que pasa por detrás).

#### Estructura de Carpetas Propuesta:
```bash
src/
  ├── components/       # Piezas de LEGO reutilizables (Botones, Inputs, Cards)
  │   ├── ui/           # Componentes puramente visuales
  │   └── features/     # Componentes específicos de negocio (ej: TribeCard)
  ├── screens/          # "Páginas" completas (Dashboard, Login, Perfil)
  │   ├── auth/         # Login, Registro
  │   └── app/          # Dashboard, Tribu, Buscador
  ├── navigation/       # Configuración de rutas (Router, ProtectedRoutes)
  ├── hooks/            # Lógica extraída (useMatchmaking, useAuth)
  ├── services/         # Tu código actual de servicios (limpio)
  └── context/          # Estados globales (AuthContext)
```

### Criterio de Separación: ¿Cuándo creo un archivo nuevo?
1.  **Screens (Contenedores):** Si tiene una ruta propia en el navegador (ej: `/dashboard`, `/login`), es una **Screen**.
    *   *Ejemplo:* Todo el código dentro de `RegisterScreen` que hoy vive en App.tsx se mueve a `src/screens/auth/RegisterScreen.tsx`.
2.  **Componentes (Presentational):** Si es un trozo de UI que se repite o es muy largo.
    *   *Ejemplo:* `ActivityView` o `DirectoryView` se mueven a `src/components/features/`.
3.  **Hooks (Lógica):** Si hay muchos `useState` y `useEffect` juntos manejando algo específico.
    *   *Ejemplo:* Todo el código de `activateTrialMembership` y el manejo de fechas puede ir a `src/hooks/useMembership.ts`.

### Plan de Acción (Extracción Gradual)
1.  **Paso 1 (Navigation):** Mover el `HashRouter` y `<Routes>` a `src/navigation/AppNavigator.tsx`.
2.  **Paso 2 (Screens Grandes):** Mover `RegisterScreen` y `SurveyScreen` a sus propios archivos.
3.  **Paso 3 (Hooks):** Extraer lógica de persistencia a custom hooks.

## 3. Seguridad en "Mes Gratis"
**Problema:** Activación del lado del cliente sin verificación. Abusable.
**Estrategia:** Validación Server-Side (Cloud Functions).
1.  **Backend (Cloud Function):** Crear una función `activateTrial(userId)`.
2.  **Lógica:**
    *   Recibe ID de usuario.
    *   Verifica en BD si *este dispositivo/IP/Email* ya tuvo trial antes (requires más datos de rastreo) o simplemente marcar un flag `hasUsedTrial: true` en el documento del usuario.
    *   Si es válido, escribe las fechas de inicio/fin en Firestore (con `adminSDK`, no cliente).
3.  **Cliente:** Cambiar la App para llamar a esta función en lugar de escribir directo en Firestore.

## 4. Servicios Duplicados (`firebase` vs `firestore`)
**Problema:** Código redundante y confuso. `firebaseService.ts` maneja Auth/Messaging/Storage, mientras que `firestoreService.ts` duplica Auth y añade lógica de DB (Checklists, Asignaciones).

### Plan de Unificación:
Crearemos una fachada única para que la App no sepa "de dónde" vienen los datos.
1.  **Nuevo Módulo:** `src/services/api/`
    *   `auth.ts`: Login, Registro, Reset Password.
    *   `users.ts`: Perfiles, Fotos.
    *   `tribes.ts`: Matchmaking, Asignaciones, Checklists.
    *   `notifications.ts`: FCM, Push.
2.  **Refactor:** Mover funciones una por una.
    *   *Ejemplo:* Mover `loginWithEmail` de `firestoreService` a `auth.ts`.
3.  ** Limpieza:** Eliminar `firebaseService.ts` y `firestoreService.ts` antiguos.

## 2. App Monolítica (`App.tsx` gigante) - Continuación
### Gestión de Estado (State Management)
Al dividir la app, ¿dónde guardamos los datos?
1.  **Estado Global (Context API):** Para cosas que "casi nunca cambian" o se usan en todos lados.
    *   `AuthContext`: ¿Quién es el usuario actual?
    *   `ThemeContext`: ¿Modo oscuro o claro?
2.  **Estado de Servidor (React Query / SWR):** Para datos que vienen de la BD.
    *   En lugar de `useEffect` manuales para traer asignaciones, usaremos hooks: `const { data: assignments } = useTribeAssignments(userId);`.
    *   Esto maneja caché, loading y errores automáticamente.

## 5. Falta de Tests (Matchmaking)
**Problema:** Lógica crítica sin red de seguridad.
**Estrategia:** Test Unitarios (Vitest).
1.  **Instalación:** Configurar Vitest (rápido y compatible con Vite).
2.  **Tests de Match:** Crear `tests/matchService.test.ts`.
    *   *Caso 1:* Usuario A (Interés: "Marketing") vs Usuario B (Rubro: "Marketing"). -> Debe hacer Match.
    *   *Caso 2:* Usuario C (Interés: "Cocina") vs Usuario B. -> No Match.
3.  **CI (Opcional):** Correr tests antes de cada deploy.

## 6. Estrategia de Documentación (Para no perderse)
**Problema:** "Si dividimos todo, ¿cómo sé dónde están las cosas?"
**Solución:**
1.  **Mapa del Sitio (`ARCHITECTURE.md`):** Un archivo vivo que explica qué hace cada carpeta.
    *   *Ejemplo:* "src/hooks/useMatchmaking.ts -> Contiene el algoritmo de afinidad."
2.  **Nombres Claros (Self-documenting):**
    *   Mal: `utils.ts` (¿Qué hay ahí? ¿Todo?)
    *   Bien: `dateFormatter.ts`, `rutValidator.ts`
3.  **Comentarios JSDoc:** Usar comentarios estándar encima de funciones complejas para que el VS Code te muestre ayudas flotantes.

---

## Orden Sugerido de Ejecución
Recomiendo este orden por **Riesgo vs Beneficio**:

1.  **Datos (Punto 1):** Alto beneficio inmediato, riesgo medio (controlado con backup).
2.  **Arquitectura (Punto 2 + 6):** Alto beneficio a largo plazo. *Incluye crear ARCHITECTURE.md*.
3.  **Servicios (Punto 4):** Limpieza necesaria para facilitar el Punto 2.
4.  **Tests (Punto 5):** Fundamental antes de tocar lógica compleja futura.
5.  **Seguridad (Punto 3):** Importante, pero quizás menos urgente si el volumen de fraude es bajo hoy.
